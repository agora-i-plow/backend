# Разработка системы с web-интерфейсом для сопоставления характеристик товаров маркетплейса с их эталонными значениями

> Команда: ***i plow()***
>
> Кейс решён в рамках хакатона [AgoraHack2022](https://hackathon.agora.ru/)
---
## Постановка задачи

Дана база товаров со следующими полями.

| Поле           | Инфо                                                           |
| -------------- | -------------------------------------------------------------- |
| `name`         | Наименование товара                                            |
| `is_reference` | True, если товар является эталоном. Тогда reference_id "None". |
| `product_id`   | id продукта                                                    |
| `reference_id` | id эталона для этого продукта                                  |
| `props`        | массив строк-свойств товара                                    |

В ней имеются как товары-эталоны (471 шт.), так и товары продавцов (2780 шт.)

Основываясь на этих данных необходимо разработать микросервис, сопостовляющий товары продавцов с эталонами. Взаимодействие с сервисом должно осуществляться посредством отправки POST запроса с JSON-массивом, содержащим товары. Ответ сервиса должен состоять из id эталонов для каждого товара.

## Оглавление

1. [Задача](#Постановка-задачи)
2. [Алгоритм](#Алгоритм)
3. [Ход решения](#Ход-решения)
4. [Дополнительные фичи](#Дополнительные-фичи)
5. [Наш Стек](#Наш-стек)
6. [Архитектура микросервиса](#Архитектура-микросервиса)
7. [Как запустить?](#как-запустить)
8. [i plow()](#i-plow---это-мы)


## Алгоритм

Для матчинга поступающего на вход сервису товара мы выполняем следующие действия:

1. Отдаем название товара в MongoDB - перед поиском он автоматически производит лемматизацию названия.
2. Затем  производится полнотекстовый поиск по названию товара по имеющимся эталонам, чтобы найти схожие.
3. После мы выбираем эталон с наибольшим textScore и возвращаем его id.

## Ход решения

### Первая неплохая попытка

Для оценки результатов работы нашего алгоритма в качестве метрики мы выбрали Accuracy.

`Accuracy = Количество верно предсказанных эталоннов / Количество предсказаний`

Тесты проводились на устройстве с 8 ГБ оперативной памяти и процессором AMD FX(tm)-4350 Quad-Core Processor, информацию о котором вы можете видеть ниже.

```shell
$ cpufetch
Name:              AMD FX(tm)-4350 Quad-Core Processor 
Microarchitecture: Piledriver
Technology:        32nm
Max Frequency:     4.200 GHz
Cores:             2 cores (4 threads)
AVX:               AVX
FMA:               FMA3,FMA4
L1i Size:          64KB (128KB Total)
L1d Size:          16KB (64KB Total)
L2 Size:           2MB (4MB Total)
L3 Size:           8MB
Peak Performance:  134.40 GFLOP/s
```

Сперва мы просто произвели поиск MongoDB по названию. 
Производительность нашего решения мы оценивали, подавая на вход алгоритму батчи разных размеров (при этом матчинг производился относительно всех предоставленных эталонов). Результаты первого подхода можно увидеть ниже.

| Размер батча | Время обработки батча (с) | Скорость матчинга (Матчей/сек) | Accuracy |
| ------------ | ------------------------- | ------------------------------ | -------- |
| 100          | 0.2715                    | ~ 368                          | 0.8800   |
| 1000         | 1.6553                    | ~ 604                          | 0.8840   |
| 2780         | 4.7229                    | ~ 589                          | 0.8996   |
| ------------ | ----------------          | ----------------------------   | -------- |
| В среднем    | -                         | ~ 520                          | 0.8878   |

Мы получили недурное качество, но мы видели еще горизонты для улучшения наших результатов. 

### Как мы улучшали качество матчинга

1. Мы использовали свойства товаров при поиске (props)

Придумали конкатенировать их с названием товара и искать по ним обоим. В итоге это значительно повлияло на скорость предсказания, зато мы добились повышения точности на 0.04, по сравнению с прошлым вариантом, что является значительным приростом и увеличло точность нашей модели до ~0.935. результаты бенчмарков можно видеть ниже. 


| Размер батча | Время обработки батча (с) | Скорость матчинга (Матчей/сек) | Accuracy |
| ------------ | ------------------------- | ------------------------------ | -------- |
| 100          | 0.5504            | ~ 181                          | 0.9500 |
| 1000         | 5.5677                   | ~ 179                          | 0.9260   |
| 2780         | 16.7053                   | ~ 166                         | 0.9309   |
| ------------ | ----------------          | ----------------------------   | -------- |
| В среднем    | -                         | ~ 175                | 0.9356   |

Как можно заметить, время обработки батчей увеличилось практически вдвое, а то и втрое (оно и ясно, текста стало в два три раза больше на каждый товар), вдобавок это с лихвой окупилось повышением точности. По ТЗ скорость матчинга должна быть не менее 100 товаров в секунду, и в этот интервал мы все ещё укладываемся.

2. (Неудачно) Разделили и добавили по частям именования со спецсимволами. (Было "сплит-система", стало "сплит-система сплит система")

При таком подходе точность модели снизилась где-то на 8-12 процентов, поэтому мы отказались от этой затеи. Предположительно эта идея не сработала, поскольку она уменьшала связи между словами и общее количество уникальных слов, путала поиск и тем самым ухудшала нахождение правильного эталона.

## Дополнительные фичи

- Система пользовательских прав - Набор методов для интеграции системы пользовательских прав.
- Оперирование данными - Набор методов для добавления новых эта.
- Простота использования - Интерактивная документация, предоставляемая FastApi, позволяет "пощупать" API с помощью web-интерфейса.
- Простота интеграции - Контейнеризация микросервиса с помощью Docker, позволяющая без лишних усилий интегрировать его в рабочий процесс.
- Безграничная масштабируемость - нет необходимости переобучать модель при добавлении новых эталонов.
- Высокая производительность - высокая скорость работы алгоритма позволяет использовать этот микросервис в HighLoad проектах.

## Наш Стек

- [Python](https://www.python.org/) - основной язык
- [FastApi](https://fastapi.tiangolo.com/) - Rest/API
- [pymystem3](https://yandex.ru/dev/mystem/) - лемматизация эталонов
- [MongoDB](https://www.mongodb.com/) - хранение и поиск по эталонам
- [PostgreSQL](https://www.postgresql.org/?&) - хранение информации о пользователях
- [Docker, docker-compose](https://www.docker.com/) - контейнеризация
- [uvicorn](https://www.uvicorn.org/) - асинхронный фреймворк для веб-сервера


## Архитектура микросервиса

![image](https://user-images.githubusercontent.com/53406289/185759996-0597f172-6aa9-48d3-995a-2cdc4f08deb5.png)


## Как запустить?

![screencast](https://user-images.githubusercontent.com/53406289/185760859-5b7d8aef-78c7-434b-889b-e324471f803a.gif)


### Технические требования
Для запуска решения требуется наличие в системе следующих утилит:
- `Python` версии `3.10` и выше
- `Docker`
- `docker-compose` версии `2.6` и выше
- `Make`

### Подготовка к запуску
1) При необходимости вы можете отредактировать файл конфига `.env` под свои нужды, со следующим содержимым:
```shell
POSTGRES_USERNAME=...
POSTGRES_PASSWORD=...
POSTGRES_DATABASE=...
POSTGRES_HOST=...

MONGO_USER=...
MONGO_PASSWORD=...
MONGO_DATABASE=...
MONGO_HOST=...

FASTAPI_PORT=...
FASTAPI_SECRET=...
FASTAPI_HASH_ALGORITHM=...
FASTAPI_HASH_EXPIRATION=...
```

2) Запуск баз данных:
```shell
make db
```

### Запуск в докере
```shell
make run
```
После этого ваш сервис станет доступен на `localhost:8080`, если вы не меняли порт в `.env`, а на `localhost:8080/docs` будет располагаться документация по API.

Чтобы выключить все контейнеры (в т.ч. и базы данных), пропишите `make down`.

### Запуск локально
1) Создание виртуальной среды и установка зависимостей:
```shell
make prepare
```
2) Запуск сервиса:
```shell
make run-local
```

### Тестирование сервиса

Для тестирования сервиса удобно использовать `curl`:
```shell
$ curl -X 'POST' \
  'http://0.0.0.0:8100/match_products' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '[
  {
    "id": "0039af5efceac4ab",
    "name": "Холодильник Бирюса 118",
    "props": [
      "Мощность  замораживания  4 кг/сутки"
    ]
  },
  {
    "id": "004f2158acb8165c",
    "name": "ASUS TUF-GTX1660S-O6G-GAMING Видеокарта",
    "props": [
      "Объем  видеопамяти\t6144 МБ",
      "Частота  памяти\t14002 МГц",
      "Разъемы   и интерфейсы выход DVI, выход DisplayPort, выход HDMI"
    ]
  }
]'
[{"id":"0039af5efceac4ab","reference_id":"28085e941cde1639"},{"id":"004f2158acb8165c","reference_id":"9afe55bb4bf1e8a8"}]
```
## Остались вопросы? Проблемы с тестированием решения?

Обратитесь к нам! Мы будем рады вам помочь и ответить на все ваши вопросы.

## i plow() - это мы

>- Голубев Егор - бекенд-разработчик
>- Тампио Илья - ML-специалист
>- Лернер Роман - Product менеджер
>- Молоткова Ника - UI/UX дизайнер
>- Лебедева Татьяна - Frontend-разработчик
